declare module 'skyway-js' {
    export = Peer
}

declare class Peer {
    constructor(options: Peer.PeerOption)
    constructor(id: string, options: Peer.PeerOption)
    /**
     * The Peer ID specified by a user or randomly assigned Peer ID by the signaling server.
     */
    id: string;

    /**
     * Object contains all connections.
     */
    connections: any;

    /**
     * Whether the socket is connecting to the signalling server or not.
     */
    open: boolean;

    /**
     * Object contains all rooms.
     */
    rooms: any;

    /**
     * Calls the designated Peer and creates new MediaConnection.
     * @param peerId The peerId of the peer you are calling.
     * @param stream The MediaStream to send to the remote peer. If not set, the caller creates offer SDP with `recvonly` attribute.
     * @param options Optional arguments for the connection.
     */
    call(peerId: string, stream?: MediaStream, options?: Peer.PeerCallOption): Peer.MediaConnection;

    /**
    * Connects to the designated Peer and creates new DataConnection.
    * @param peerId User's peerId.
    * @param options Optional arguments for DataConnection.
    */
    connect(peerId: string, options?: Peer.PeerConnectOption): Peer.DataConnection;

    /**
     * Close the connection to the server, leaving all existing data and media connections intact.
     */
    disconnect(): void;

    /**
     * Close all connections and disconnect socket.
     */
    destroy(): void;

    /**
     * Join fullmesh type or SFU type room that two or more users can join.
     * @param roomName The name of the room user is joining to.
     * @param option Options to configure connection
     */
    joinRoom(roomName: string, option?: Peer.RoomOption): Peer.SFURoom | Peer.MeshRoom;

    /**
     * Call Rest API and get the list of peerIds assciated with API key.
     * @param cb Callback function 
     */
    listAllPeers(cb: (peerIds: Array<string>) => void): void;

    /**
    * Update server-side credential by sending a request in order to extend TTL.
    * @param option The new credential generated by user.
    */
    updateCredential(option: Peer.CredentialOption): void;

    /**
    * @param event Event name
    * @param cb Callback function
    */
    on(event: string, cb: () => void): void;

    /**
    * Received a call from peer.
    * @param event Event name
    * @param cb Callback function
    */
    on(event: 'call', cb: (mediaConnection: Peer.MediaConnection) => void): void;

    /**
     * Finished closing all connections to peers.
     * @param event Event name
     * @param cb Callback function
     */
    on(event: 'close', cb: () => void): void;

    /**
    * Received a connection from peer.
    * @param event Event name
    * @param cb Callback function
    */
    on(event: 'connection', cb: (dataConnection: Peer.DataConnection) => void): void;

    /**
    * Disconnected from the signalling server.
    * @param event Event name
    * @param cb Callback function
    */
    on(event: 'disconnected', cb: (id: string) => void): void;

    /**
     * Successfully connected to signaling server.
     * @param event Event name
     * @param cb id is the brokering ID of the peer
    */
    on(event: 'open', cb: (id: string) => void): void;


    /**
     * Error occurred.
     * @param event Event name
     * @param cb Callback function
     */
    on(event: 'error', cb: (err: Error) => void): void;

}

declare namespace Peer {
    interface PeerOption {
        /**
         * ECLWebRTC API key.
         */
        key: string;
        /**
         * Log level.NONE: 0, ERROR: 1, WARN: 2, FULL: 3.
         */
        debug?: number;
        /**
         *  A RTCConfiguration dictionary for the RTCPeerConnection.
         */

        config?: RTCConfiguration;
        /**
         *  Whether using ECLWebRTC's TURN or not.
         */

        turn?: boolean;
        /**
         * The credential used to authenticate peer.
         */

        credential?: CredentialOption;
    }
    interface CredentialOption {
        /**
         * Current UNIX timestamp.
         */
        timestamp?: number;
        /**
         *   Time to live; The credential expires at timestamp + ttl.
         */
        ttl?: number;
        /**
         * Credential token calculated with HMAC.
         */
        authToken?: string;
    }
    interface PeerConnectOption {
        /**
         * Label to easily identify the connection on either peer.
         */
        label?: string;
        /**
         * Any additional information to send to the peer.
         */
        metadata?: any;
        /**
         * How to serialize data when sending. One of 'binary', 'json' or 'none'.
         */
        serialization?: string;
    }
    interface PeerCallOption {
        /**
         * Label to easily identify the connection on either peer.
         */
        label?: string;
        /**
         * A max video bandwidth(kbps)
         */
        videoBandwidth?: number;
        /**
         * A max audio bandwidth(kbps)
         */
        audioBandwidth?: number;
        /**
         * A video codec like 'H264'
         */
        videoCodec?: string;
        /**
         *  A video codec like 'PCMU'
         */
        audioCodec?: string;
    }
    interface RoomOption {
        /**
         * One of 'sfu' or 'mesh'.
         */
        mode?: string;
        /**
         *  Media stream user wants to emit.
         */
        stream?: MediaStream;
        /**
         * A max video bandwidth(kbps)
         */
        videoBandwidth?: number;
        /**
         * A max audio bandwidth(kbps)
         */
        audioBandwidth?: number;
        /**
         * A video codec like 'H264'
         */
        videoCodec?: string;
        /**
         *  A video codec like 'PCMU'
         */
        audioCodec?: string;
    }

    interface AnswerOption {
        /**
        * A max video bandwidth(kbps)
        */
        videoBandwidth?: number;
        /**
         * A max audio bandwidth(kbps)
         */
        audioBandwidth?: number;
        /**
         * A video codec like 'H264'
         */
        videoCodec?: string;
        /**
         *  A video codec like 'PCMU'
         */
        audioCodec?: string;
    }
    interface DataConnection {
        /**
         * Label to easily identify the DataConnection on either peer.
         */
        label: string;

        /**
         * Any additional information to send to the peer.
         */
        metadata: any;

        /**
         * Whether the Connection has been opened or not.
         */
        open: boolean;

        /**
         * The remote peerId.
         * @deprecated Use remoteId instead.
         */
        peer: string;

        /**
         * PeerId of the peer this connection is connected to.
         */
        remoteId: string;

        /**
         * The connection type. Either 'media' or 'data'.
         */
        type: string;

        /**
         * Disconnect from remote peer.
         */
        close(): void;

        /**
         * Send data to peer. If serialization is 'binary', it will chunk it before sending.
         * @param data The data to send to the peer.
         */
        send(data: any): void;

        /**
         * Connection closed event.
         * @param event Event name
         * @param cb Callback function
         */
        on(event: 'close', cb: () => void): void;
    }

    interface MediaConnection {
        /**
         * The local MediaStream.
         */
        localStream: MediaStream

        /**
         * Any additional information to send to the peer.
         */
        metadata: any;

        /**
         * Whether the Connection has been opened or not.
         */
        open: boolean;

        /**
         * The remote peerId.
         * @deprecated Use remoteId instead.
         */
        peer: string;

        /**
         * PeerId of the peer this connection is connected to.
         */
        remoteId: string;

        /**
         * The connection type. Either 'media' or 'data'.
         */
        type: string;

        answer(stream: MediaStream, option: AnswerOption): void;

        /**
         * Disconnect from remote peer.
         */
        close(): void;


        /**
         * Replace the stream being sent on all MediaConnections with a new one.
         * @param newStream The stream to replace the old stream with.
         */
        replaceStream(newStream: MediaStream): void;

        /**
         * @param event Event name
         * @param cb Callback function
         */
        on(event: string, cb: () => void): void;

        /**
         * Connection closed event.
         * @param event Event name
         * @param cb Callback function
         */
        on(event: 'close', cb: () => void): void;

        /**
        * Received a connection from peer.
        * @param event Event name
        * @param cb Callback function
        */
        on(event: 'removeStream', cb: (stream: MediaStream) => void): void;


        /**
         * MediaStream received from peer.
         * @param event Event name
         * @param cb Callback function
         */
        on(event: 'stream', cb: (stream: MediaStream) => void): void;
    }

    interface SFURoom {
        /**
         * Close PeerConnection and emit leave and close event.
         */
        close(): void;

        /**
         * Start getting room's logs from signaling server.
         */
        getLog(): void;

        /**
         * Replace the stream being sent on all MediaConnections with a new one.
         * @param newStream The stream to replace the old stream with.
         */
        replaceStream(newStream: MediaStream): void;

        /**
         * Send data to all participants in the room with WebSocket. It emits broadcast event.
         * @param data The data to send.
         */
        send(data: any): void;

        /**
        * @param event Event name
        * @param cb Callback function
        */
        on(event: string, cb: () => void): void;

        /**
         * All connections in the room has closed.
         * @param event Event name
         * @param cb Callback function
         */
        on(event: 'close', cb: () => void): void;

        /**
        * Data received from peer.
        * @param event Event name
        * @param cb Callback function
        */
        on(event: 'data', cb: (src: string, data: any) => void): void;

        /**
         * Error occurred.
         * @param event Event name
         * @param cb Callback function
         */
        on(event: 'error', cb: () => void): void;

        /**
        * Room's log received.
        * @param event Event name
        * @param cb Callback function
        */
        on(event: 'log', cb: (logs: Array<any>) => void): void;

        /**
         * Successfully connected to signaling server.
         * @param event Event name
         * @param cb id is the brokering ID of the peer
        */
        on(event: 'open', cb: (id: string) => void): void;

        /**
        * New peer has joined.
        * @param event Event name
        * @param cb Callback function
        */
        on(event: 'peerJoin', cb: (id: string) => void): void;

        /**
        * A peer has left.
        * @param event Event name
        * @param cb Callback function
        */
        on(event: 'peerLeave', cb: (id: string) => void): void;

        /**
        * MediaStream received from peer in the room.
        * @param event Event name
        * @param cb Callback function
        */
        on(event: 'data', cb: (stream: MediaStream) => void): void;
    
        /**
        * MediaStream received from peer in the room.
        * @param event Event name
        * @param cb Callback function
        */
        on(event: 'stream', cb: (stream: MediaStream) => void): void;
    }

    interface MeshRoom {
        /**
         * Close all connections in the room.
         */
        close(): void;

        /**
         * Start getting room's logs from signaling server.
         */
        getLog(): void;

        /**
         * Replace the stream being sent on all MediaConnections with a new one.
         * @param newStream The stream to replace the old stream with.
         */
        replaceStream(newStream: MediaStream): void;

        /**
         * Send data to all participants in the room with WebSocket. It emits broadcast event.
         * @param The data to send.
         */
        send(data: any): void;

        /**
         * All connections in the room has closed.
         * @param event Event name
         * @param cb Callback function
         */
        on(event: 'close', cb: () => void): void;

        /**
        * Data received from peer.
        * @param event Event name
        * @param cb Callback function
        */
        on(event: 'data', cb: (src: string, data: any) => void): void;

        /**
         * Error occurred.
         * @param event Event name
         * @param cb Callback function
         */
        on(event: 'error', cb: () => void): void;

        /**
        * Room's log received.
        * @param event Event name
        * @param cb Callback function
        */
        on(event: 'log', cb: (logs: Array<any>) => void): void;

        /**
         * Successfully connected to signaling server.
         * @param event Event name
         * @param cb id is the brokering ID of the peer
        */
        on(event: 'open', cb: (id: string) => void): void;

        /**
        * New peer has joined.
        * @param event Event name
        * @param cb Callback function
        */
        on(event: 'peerJoin', cb: (id: string) => void): void;

        /**
        * A peer has left.
        * @param event Event name
        * @param cb Callback function
        */
        on(event: 'peerLeave', cb: (id: string) => void): void;

        /**
        * MediaStream received from peer in the room.
        * @param event Event name
        * @param cb Callback function
        */
        on(event: 'data', cb: (stream: MediaStream) => void): void;
        
        /**
        * MediaStream received from peer in the room.
        * @param event Event name
        * @param cb Callback function
        */
        on(event: 'stream', cb: (stream: MediaStream) => void): void;
    }
}
